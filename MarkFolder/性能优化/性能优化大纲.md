#性能优化提纲--黄梁享

##1、代码优化
 >1、IO流记得close、避免内存泄漏，IO缓存：
使用具有缓存策略的输入流，BufferedInputStream替代InputStream，BufferedReader替代Reader，BufferedReader替代BufferedInputStream.对文件、网络IO皆适用。<br>
 >2、数据库、Cusor、记得关闭<br>
 >3、循环内创建对象需要注意，最好在外面定义一个变量接收，避免开辟过多的栈内存。不要在循环当中声明临时变量，不要在循环中捕获异常。<br>
 >4、构造Adapter时，要使用缓存的 convertView，这个一般人都会使用的。但是有些应用为了特殊效果会没有复用。<br>
 >5、Bitmap对象不在使用时调用recycle()释放内存<br>
 >6、释放对象的引用，特别是一些很占用资源的对象，确定没再使用后，最好置为null。<br>
 >7、递归和循环之间按需要开辟栈空间的变量去选择。因为有时候递归算法往往要消耗大量栈空间，有可能导致栈溢出<br>
 >8、注意数据结构、集合类的使用
 ><pre>
java.util包中已经定义好了很多我们可以随手拿来用的工具了，比如各种集合。Android还定义了一些为了解决性能问题而生的类：
LruCache
SparseArray
SparseBooleanArray
SparseIntArray
Pair
</pre>

>9、必要时使用StringBuffer、StringBuidler、String.format() 做字符串拼接优化<br>
>10、静态变量引起内存泄露----静态变量从所在的类被使用开始就要一直占用着内存空间，直到程序退出。
><a href="http://blog.csdn.net/xygy8860/article/details/53334476?utm_source=itdadao&utm_medium=referral">参考博客地址</a>
><pre>
private static Resources mResources; 
@Override
protected void onCreate(Bundle state) {
super.onCreate(state);
if (mResources == null) {
    mResources = this.getResources();
    }
}
这段代码中有一个静态的Resources对象。代码片段mResources = this.getResources()对Resources对象进行了初始化。
这时Resources对象拥有了当前Activity对象的引用，Activity又引用了整个页面中所有的对象。
经验分享：
在实际项目中，我们经常会把一些对象的引用加入到集合中，如果这个集合是静态的话，就需要特别注意了。当不需要某对象时，
务必及时把它的引用从集合中清理掉。或者可以为集合提供一种更新策略，及时更新整个集合，这样可以保证集合的大小不超过某值，
避免内存空间的浪费
</pre>

<pre>经验分享：
代码的微优化有很多很多东西可以讲，小到一个变量的声明，大到一段算法。尤其在代码Review的过程中，可能会反复审查代码是否可以优化。
不过我认为，代码的微优化是非常耗费时间的，没有必要从头到尾将所有代码都优化一遍。开发者应该根据具体的业务逻辑去专门针对某部分代码做优化。
比如应用中可能有一些方法会被反复调用，那么这部分代码就值得专门做优化。其它的代码，需要开发者在写代码过程中去注意。</pre>

##2、布局优化

一般我们人眼看到的图像帧率为60fps的时候，会感到比较流畅，换算成时间就是0.16s/帧，如果你的应用某个点再0.16s之内没有渲染完成，就会造成所谓的卡顿
>1、减少布局的嵌套与ViewStub推迟对象创建，<br>
>2、如果可以尽量利用系统的静态资源  <a href="http://blog.csdn.net/xygy8860/article/details/53334476?utm_source=itdadao&utm_medium=referral">参考博客地址</a><br>
><pre>
>1）利用系统定义的id.
>2）利用系统的图片资源.
>3）利用系统的字符串资源
>4）利用系统的Style
>5）利用系统的颜色定义
>经验分享：
Android中没有公开的资源，在xml中直接引用会报错。除了去找到对应资源并拷贝到我们自己的应用目录下使用以外，
我们还可以将引用“@android”改成“@*android”解决。比如上面引用的附件图标，可以修改成下面的代码。
android:icon="@*android:drawable/ic_menu_attachment"
修改后，再次Build工程，就不会报错了。
></pre>
>3、<include /> 标签来重用layout的代码。<pre>
经验分享：
一般情况下，在项目的初期就能够大致确定整体UI的风格。所以早期的时候就可以做一些规划，将通用的模块先写出来。
下面是可能可以抽出的共用的布局：
1）背景。有的应用在不同的界面里会用到统一的背景。后期可能会经常修改默认背景，所以可以将背景做成一个通用模块。
2）头部的标题栏。如果应用有统一的头部标题栏，就可以抽取出来。
3）底部的导航栏。如果应用有导航栏，而且大部分的Activity的底部导航栏是相同的，就可以将导航栏写成一个通用模块。
4）ListView。大部分应用都会用到ListView展示多条数据。项目后期可能会经常调整ListView的风格，所以将ListView作为一个通用的模块比较好。</pre>
>4、界面延迟加载技术。ViewStub是一个隐藏的，不占用内存空间的视图对象。直到调用setVisibility(int)或者inflate()为止



##3、WebView优化
<a href="http://blog.csdn.net/xygy8860/article/details/53334476?utm_source=itdadao&utm_medium=referral">参考博客地址</a>
>找到了原因后，解决方案也比较简单，核心思路就是让onDetachedFromWindow先走，那么在主动调用之前destroy()，把webview从它的parent上面移除掉
<pre>
public void destroy() {
    if (mWebView != null) {
        // 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再
        // destory()
        ViewParent parent = mWebView.getParent();
        if (parent != null) {
            ((ViewGroup) parent).removeView(mWebView);
        }

        mWebView.stopLoading();
        // 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错
        mWebView.getSettings().setJavaScriptEnabled(false);
        mWebView.clearHistory();
        mWebView.clearView();
        mWebView.removeAllViews();

        try {
            mWebView.destroy();
        } catch (Throwable ex) {

        }
    }
}
</pre>

##4、图片优化
><h5>1、Bitmap</h5>
>及时的销毁(Activity的onDestroy时将bitmap回收，在被UI组件使用后马上进行回收会抛 RuntimeException:Canvas:tryingtousearecycledbitmapandroid.graphics.Bitmap) <br>
><h5>2、Drawable</h5>
ui组件需要用到的图片是apk包自带的，那么一律用setImageResource或者setBackgroundResource，而不要根据resourceid
注意：get(getResources(),R.drawable.btn_achievement_normal)该方法通过resid转换为drawable，需要考虑回收的问题，如果drawable是对象私有对象，在对象销毁前是肯定不会释放内存的。

##5、线程优化

##6、电池优化